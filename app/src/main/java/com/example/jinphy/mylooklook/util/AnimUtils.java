/*
 * Copyright 2015 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.example.jinphy.mylooklook.util;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.AnimatorSet;
import android.animation.ObjectAnimator;
import android.animation.TimeInterpolator;
import android.animation.ValueAnimator;
import android.content.Context;
import android.graphics.ColorMatrixColorFilter;
import android.support.annotation.FloatRange;
import android.support.annotation.IntRange;
import android.support.annotation.NonNull;
import android.transition.Transition;
import android.util.ArrayMap;
import android.util.Property;
import android.view.View;
import android.view.animation.AnimationUtils;
import android.view.animation.Interpolator;
import android.widget.ImageView;

import java.util.ArrayList;

/**
 * Utility methods for working with animations.
 */
public class AnimUtils {

    private AnimUtils() { }

    private static Interpolator fastOutSlowIn;
    private static Interpolator fastOutLinearIn;
    private static Interpolator linearOutSlowIn;

    public static Interpolator getFastOutSlowInInterpolator(Context context) {
        if (fastOutSlowIn == null) {
            fastOutSlowIn = AnimationUtils.loadInterpolator(context,
                    android.R.interpolator.fast_out_slow_in);
        }
        return fastOutSlowIn;
    }

    public static Interpolator getFastOutLinearInInterpolator(Context context) {
        if (fastOutLinearIn == null) {
            fastOutLinearIn = AnimationUtils.loadInterpolator(context,
                    android.R.interpolator.fast_out_linear_in);
        }
        return fastOutLinearIn;
    }

    public static Interpolator getLinearOutSlowInInterpolator(Context context) {
        if (linearOutSlowIn == null) {
            linearOutSlowIn = AnimationUtils.loadInterpolator(context,
                    android.R.interpolator.linear_out_slow_in);
        }
        return linearOutSlowIn;
    }

    /**
     * Linear interpolate between a and b with parameter t.
     */
    public static float lerp(float a, float b, float t) {
        return a + (b - a) * t;
    }


    /**
     * An implementation of {@link Property} to be used specifically with fields of
     * type
     * <code>float</code>. This type-specific subclass enables performance benefit by allowing
     * calls to a {@link #set(Object, Float) set()} function that takes the primitive
     * <code>float</code> type and avoids autoboxing and other overhead associated with the
     * <code>Float</code> class.
     *
     * @param <T> The class on which the Property is declared.
     **/
    public static abstract class FloatProperty<T> extends Property<T, Float> {
        public FloatProperty(String name) {
            super(Float.class, name);
        }

        /**
         * A type-specific override of the {@link #set(Object, Float)} that is faster when dealing
         * with fields of type <code>float</code>.
         */
        public abstract void setValue(T object, float value);

        @Override
        final public void set(T object, Float value) {
            setValue(object, value);
        }
    }

    /**
     * An implementation of {@link Property} to be used specifically with fields of
     * type
     * <code>int</code>. This type-specific subclass enables performance benefit by allowing
     * calls to a {@link #set(Object, Integer) set()} function that takes the primitive
     * <code>int</code> type and avoids autoboxing and other overhead associated with the
     * <code>Integer</code> class.
     *
     * @param <T> The class on which the Property is declared.
     */
    public static abstract class IntProperty<T> extends Property<T, Integer> {

        public IntProperty(String name) {
            super(Integer.class, name);
        }

        /**
         * A type-specific override of the {@link #set(Object, Integer)} that is faster when dealing
         * with fields of type <code>int</code>.
         */
        public abstract void setValue(T object, int value);

        @Override
        final public void set(T object, Integer value) {
            setValue(object, value.intValue());
        }

    }

    /**
     * https://halfthought.wordpress.com/2014/11/07/reveal-transition/
     * <p/>
     * Interrupting Activity transitions can yield an OperationNotSupportedException when the
     * transition tries to pause the animator. Yikes! We can fix this by wrapping the Animator:
     */
    public static class NoPauseAnimator extends Animator {
        private final Animator mAnimator;
        private final ArrayMap<AnimatorListener, AnimatorListener> mListeners =
                new ArrayMap<AnimatorListener, AnimatorListener>();

        public NoPauseAnimator(Animator animator) {
            mAnimator = animator;
        }

        @Override
        public void addListener(AnimatorListener listener) {
            AnimatorListener wrapper = new AnimatorListenerWrapper(this, listener);
            if (!mListeners.containsKey(listener)) {
                mListeners.put(listener, wrapper);
                mAnimator.addListener(wrapper);
            }
        }

        @Override
        public void cancel() {
            mAnimator.cancel();
        }

        @Override
        public void end() {
            mAnimator.end();
        }

        @Override
        public long getDuration() {
            return mAnimator.getDuration();
        }

        @Override
        public TimeInterpolator getInterpolator() {
            return mAnimator.getInterpolator();
        }

        @Override
        public void setInterpolator(TimeInterpolator timeInterpolator) {
            mAnimator.setInterpolator(timeInterpolator);
        }

        @Override
        public ArrayList<AnimatorListener> getListeners() {
            return new ArrayList<AnimatorListener>(mListeners.keySet());
        }

        @Override
        public long getStartDelay() {
            return mAnimator.getStartDelay();
        }

        @Override
        public void setStartDelay(long delayMS) {
            mAnimator.setStartDelay(delayMS);
        }

        @Override
        public boolean isPaused() {
            return mAnimator.isPaused();
        }

        @Override
        public boolean isRunning() {
            return mAnimator.isRunning();
        }

        @Override
        public boolean isStarted() {
            return mAnimator.isStarted();
        }

        /* We don't want to override pause or resume methods because we don't want them
         * to affect mAnimator.
        public void pause();

        public void resume();

        public void addPauseListener(AnimatorPauseListener listener);

        public void removePauseListener(AnimatorPauseListener listener);
        */

        @Override
        public void removeAllListeners() {
            mListeners.clear();
            mAnimator.removeAllListeners();
        }

        @Override
        public void removeListener(AnimatorListener listener) {
            AnimatorListener wrapper = mListeners.get(listener);
            if (wrapper != null) {
                mListeners.remove(listener);
                mAnimator.removeListener(wrapper);
            }
        }

        @Override
        public Animator setDuration(long durationMS) {
            mAnimator.setDuration(durationMS);
            return this;
        }

        @Override
        public void setTarget(Object target) {
            mAnimator.setTarget(target);
        }

        @Override
        public void setupEndValues() {
            mAnimator.setupEndValues();
        }

        @Override
        public void setupStartValues() {
            mAnimator.setupStartValues();
        }

        @Override
        public void start() {
            mAnimator.start();
        }
    }

    static class AnimatorListenerWrapper implements Animator.AnimatorListener {
        private final Animator mAnimator;
        private final Animator.AnimatorListener mListener;

        public AnimatorListenerWrapper(Animator animator, Animator.AnimatorListener listener) {
            mAnimator = animator;
            mListener = listener;
        }

        @Override
        public void onAnimationStart(Animator animator) {
            mListener.onAnimationStart(mAnimator);
        }

        @Override
        public void onAnimationEnd(Animator animator) {
            mListener.onAnimationEnd(mAnimator);
        }

        @Override
        public void onAnimationCancel(Animator animator) {
            mListener.onAnimationCancel(mAnimator);
        }

        @Override
        public void onAnimationRepeat(Animator animator) {
            mListener.onAnimationRepeat(mAnimator);
        }
    }

    public static class Builder{
        private View view;
        private float tranXFrom;
        private float tranXTo;
        private float tranYFrom;
        private float tranYTo;

        private float scaleXFrom;
        private float scaleXTo;
        private float scaleYFrom;
        private float scaleYTo;

        // 视图的饱和度渐变
        private float saturationFrom;// 饱和度起始值
        private float saturationTo; // 饱和度终止值

        private long duration = 300L;
        private Interpolator interpolator;
        private Animator.AnimatorListener listener;

        private boolean tranX = false;
        private boolean tranY = false;
        private boolean scaleX = false;
        private boolean scaleY = false;
        private boolean saturation = false;

        public Builder(@NonNull View view) {
            this.view = view;
            listener = new AnimatorListenerAdapter(){};
        }

        public Builder setTranX(float from, float to) {
            tranXFrom = from;
            tranXTo =to;
            tranX = true;
            return this;
        }

        public Builder setTranY(float from, float to) {
            tranYFrom = from;
            tranYTo = to;
            tranY = true;
            return this;
        }

        public Builder setScaleX(float from,float to) {
            scaleXFrom = from;
            scaleXTo = to;
            scaleX = true;
            return this;
        }

        public Builder setScaleY(float from, float to) {
            scaleYFrom = from;
            scaleYTo = to;
            scaleY = true;
            return this;
        }

        /**
         * 设置饱和度的渐变动画，饱和度为0是图像是灰色的，饱和度为1时是真实的颜色
         *
         * @param from 饱和度初值
         * @param to 饱和度结束值
         * */
        public Builder setSaturation(
                @FloatRange(from = 0f,to = 1f) float from,
                @FloatRange(from = 0f,to = 1f)  float to) {
            saturationFrom  =from;
            saturationTo = to;
            saturation = true;
            return this;
        }


        public Builder setDuration(@IntRange(from = 0) long duration) {
            this.duration = duration;
            return this;
        }

        public Builder setInterpolator(@NonNull Interpolator interpolator){
            this.interpolator = interpolator;
            return this;
        }

        public Builder setListener(@NonNull Animator.AnimatorListener listener) {
            this.listener = listener;
            return this;
        }

        /**
         * 创建并启动动画
         *
         * */
        public void animate() {
            build().start();
        }

        /**
         * 创建动画
         *
         * */
        public Animator build(){

            AnimatorSet set = new AnimatorSet();
            set.setDuration(duration);
            set.setInterpolator(interpolator);
            set.addListener(listener);

            AnimatorSet.Builder builder = null;
            ValueAnimator animator ;
            if (tranX) {
                animator = ValueAnimator.ofFloat(tranXFrom, tranXTo);
                animator.addUpdateListener(v -> view.setX((float) v.getAnimatedValue()));
                builder = set.play(animator);
            }
            if (tranY) {
                animator = ValueAnimator.ofFloat(tranYFrom, tranYTo);
                animator.addUpdateListener(v -> view.setY((float) v.getAnimatedValue()));
                builder = builder==null? set.play(animator):builder.with(animator);
            }
            if (scaleX) {
                animator = ValueAnimator.ofFloat(scaleXFrom, scaleXTo);
                animator.addUpdateListener(v -> view.setScaleX((float) v.getAnimatedValue()));
                builder = builder==null? set.play(animator):builder.with(animator);
            }
            if (scaleY) {
                animator = ValueAnimator.ofFloat(scaleYFrom, scaleYTo);
                animator.addUpdateListener(v -> view.setScaleY((float) v.getAnimatedValue()));
                builder = builder==null? set.play(animator):builder.with(animator);
            }
            if (saturation) {
                try {
                    ImageView imageView = ((ImageView) view);

                    final ObservableColorMatrix cm = new ObservableColorMatrix();
                    animator = ObjectAnimator.ofFloat(cm, ObservableColorMatrix.SATURATION,
                            saturationFrom, saturationTo);
                    animator.addUpdateListener(v -> imageView.setColorFilter(new
                            ColorMatrixColorFilter(cm)));

                    animator.addListener(new AnimatorListenerAdapter() {

                        @Override
                        public void onAnimationStart(Animator animation) {
                            imageView.setHasTransientState(true);
                        }

                        @Override
                        public void onAnimationEnd(Animator animation) {
                            super.onAnimationEnd(animation);
                            imageView.clearColorFilter();
                            imageView.setHasTransientState(false);
                        }
                    });

                    builder = builder==null? set.play(animator):builder.with(animator);

                } catch (ClassCastException e) {
                    e.printStackTrace();
                }
            }
            return set;
        }
    }

}
